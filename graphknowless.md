# ระบบ Knowledge Graph (KG) สำหรับ Meeting Report Generator

เอกสารฉบับนี้จัดทำขึ้นเพื่ออธิบายหลักการทำงาน โครงสร้างข้อมูล และสถาปัตยกรรมของ Knowledge Graph (KG) ที่ถูกนำมาประยุกต์ใช้ในกระบวนการสร้างรายงานการประชุมอัตโนมัติ (Meeting Workflow) เพื่อสร้างความซับซ้อนเชิงโครงสร้างและแก้ไขข้อจำกัดของโมเดลภาษาขนาดใหญ่ (Large Language Models: LLMs)

## 1. บทนำและวัตถุประสงค์ของการสร้าง Knowledge Graph

ในกระบวนการทำงานปกติเมื่อรับข้อมูลบทสนทนา (Transcript) ขนาดใหญ่เข้าสู่ LLM มักจะเกิดปัญหาเรื่องบริบทที่สับสน (Context Confusion) เช่น การนำมติของวาระหนึ่งไปใส่ในอีกวาระหนึ่ง การจำสลับผู้พูด หรือการอ้างอิงภาพประกอบสไลด์ผิดตำแหน่ง ปรากฏการณ์นี้เรียกว่า Hallucination จากบริบทที่ล้น (Context Overflow)

ระบบจึงถูกออกแบบให้มีขั้นตอน **Extraction & Linking** ทำหน้าที่สกัดองค์ประกอบย่อยออกเป็น Node และหาความสัมพันธ์ (Edges) เพื่อประกอบเป็น Knowledge Graph (KG) ไว้ในหน่วยความจำ (In-memory) ก่อนการเขียนรายงานจริง ทำให้ระบบสามารถดึงข้อมูลที่เกี่ยวข้องกับวาระเป้าหมายได้ 100% (Sub-graph querying) ก่อนส่งให้ LLM สร้างร้อยแก้ว

---

## 2. โครงสร้างของโหนด (Node Schema)

โหนดภายใน KG ถูกแบ่งออกเป็น 7 ประเภทหลัก ตาม Entity ที่สกัดได้จากที่ประชุม แต่ละโหนดจะมีโครงสร้างข้อมูล (Attributes) ดังรายละเอียดต่อไปนี้:

### 2.1 `agenda` (วาระการประชุม)

ทำหน้าที่เป็นศูนย์กลางของโครงสร้างข้อมูลรายย่อย (Root Node สำหรับ Sub-graph)

- **`type`**: `"agenda"`
- **`title`**: ชื่อเต็มของวาระ (เช่น "วาระที่ 1 เรื่องแจ้งให้ทราบ")
- **`canonical`**: คีย์ระบุตัวตนแบบมาตรฐาน (ตัดคำฟุ่มเฟือย ปรับตัวพิมพ์เล็ก) ใช้ทำ Indexing
- **`aliases`**: ขื่อเรียกอื่นๆ ที่ประเมินแล้วว่าหมายถึงวาระเดียวกัน

### 2.2 `topic` (ประเด็นอภิปรายย่อย)

เป็นเนื้อหาหลักของการพูดคุย มักยึดโยงอยู่ภายใต้ `agenda`

- **`type`**: `"topic"`
- **`title`**: หัวข้อของประเด็น
- **`details`**: บทสรุปหรือรายละเอียดของการอภิปรายหัวข้อนี้
- **`evidence`**: รายการข้อความเสียง (Transcript Text) นำมาเป็นหลักฐานอ้างอิง
- **`source_segments`**: รายการ ID (Index) ของบรรทัดต้นฉบับใน Transcript เพื่อใช้สืบค้นกลับ

### 2.3 `speaker` (ผู้พูด/ผู้เข้าร่วม)

- **`type`**: `"speaker"`
- **`name`**: ชื่อเต็มของผู้พูด หรือ Role
- **`canonical`**: ชื่อคีย์อ้างอิงมาตรฐาน (ใช้แก้ไขปัญหาพิมพ์ชื่อผิด หรือมีหลาย Alias)
- **`aliases`**: รายการชื่อรองทั้งหมดที่ระบบรวมไว้ในโหนดเดียวกัน

### 2.4 `action` (งานที่มอบหมาย / Action Items)

- **`type`**: `"action"`
- **`description`**: รายละเอียดของงานที่ตกลงกันว่าต้องดำเนินการ
- **`assignee`**: ระบุชื่อบุคคล ฝ่าย หรือตำแหน่งที่รับผิดชอบงานนี้
- **`deadline`**: กำหนดการหรือกรอบเวลาเป้าหมาย (หากมีการพูดถึง)
- **`evidence`** / **`source_segments`**: หลักฐานอ้างอิงรายประโยคและ ID
- **`related_topics`**: โหนด ID ของ Topic ที่งานนี้ถือกำเนิดขึ้น
- **`linked_agenda`**: โหนด ID ของ Agenda ที่งานนี้สังกัดอยู่

### 2.5 `decision` (มติที่ประชุม)

- **`type`**: `"decision"`
- **`description`**: ข้อความสรุปมติที่ประชุม หรือข้อตกลงร่วมกัน
- **`evidence`** / **`source_segments`**: หลักฐานอ้างอิง
- **`related_topics`**: โหนด ID ของ Topic ที่ประเมินแล้วว่าสัมพันธ์กับมตินี้
- **`linked_agenda`**: โหนด ID ของ Agenda

### 2.6 `section` (บล็อกโครงสร้างรายงาน HTML)

เป็นโหนดเชิงเทคนิคที่ใช้กำหนดโครงร่างเพื่อนำไปสร้างเอกสาร HTML Final Report

- **`type`**: `"section"`
- **`agenda_title`**: ชื่อวาระที่สัมพันธ์ด้วย
- **`anchor_index`**: ลำดับตำแหน่งอ้างอิงภายในเอกสาร
- **`kind`**: หมวดหมู่โครงสร้าง (เช่น `"summary"`, `"action_table"`)
- **`text_excerpt`**: ข้อความสรุปร่างตั้งต้น (Draft anchor) เพื่องานจับภาพประกอบลงรายงาน

### 2.7 `image` (ข้อมูลภาพประกอบ/สไลด์ที่สกัดจากวิดีโอ)

- **`type`**: `"image"`
- **`capture_index`**: ลำดับเฟรมภาพที่ตัดมา
- **`timestamp_sec`** / **`timestamp_hms`**: ระยะเวลาของวิดีโอในวินาที และรูปแบบ HH:MM:SS
- **`image_path`**: ตำแหน่งจัดเก็บรูปภาพในระบบ
- **`ocr_text`**: ตัวหนังสือดิบที่ Engine อ่านได้ในภาพนั้น
- **`ocr_text_focus`**: ตัวหนังสือที่ผ่านการประมวลผลให้เหลือเฉพาะ Keyword สำคัญ
- **`match_score`**: คะแนนรวมความสอดคล้อง (Keyword matching)
- **`matched_keywords`**: รายการคำศัพท์ที่ปรากฏในรูปและตรงกับบริบท Agenda
- _และ Attributes เชิงสถิติอื่นๆ เช่น `match_anchor_cosine`, `match_time_score` เพื่อใช้คำนวณน้ำหนัก Edges_

---

## 3. ความสัมพันธ์ของกราฟ (Edges) และกลไกการถักทอข้อมูล

Edges ภายใน KG ไม่ได้เป็นเพียงเส้นเชื่อมชี้ทิศทาง แต่โครงสร้างของ Edge บางประเภทมีการเก็บ Attributes เช่นค่าน้ำหนัก (Weights) ไว้ด้วย โดยระบบใช้อัลกอริทึมในการประกอบเส้นเหล่านี้ตามหมวดหมู่ดังนี้:

### 3.1 ความสัมพันธ์เชิงวาระและประเด็น (Structural Edges)

ถูกลิงก์ด้วย AI Logic ผ่านกระบวนการ `link_events` เมื่อตรวจพบเนื้อหา:

- **`agenda -(has_topic)-> topic`**: ผูกหัวข้อสนทนาเข้ากับวาระที่รับผิดชอบ
- **`agenda -(has_action)-> action`** และ **`topic -(has_action)-> action`**: ผูกงานมอบหมายไปยังวาระและประเด็นที่พูด
- **`agenda -(has_decision)-> decision`** และ **`topic -(has_decision)-> decision`**: ผูกมติไปหาวาระและประเด็นที่พูด
- **`speaker -(discusses)-> topic`**: หาตัวบุคคลที่พ่นประโยค (Evidence Line) ที่ตรงกับประเด็นอภิปราย แล้วลากเส้นระบุว่า "ผู้พูดคนนี้ ได้เข้าอภิปรายในหัวข้อนี้"

### 3.2 ความสัมพันธ์เชิงบริบทภาพประกอบ (Visual Context Edges)

เป็นกระบวนการของ Agent ทางคณิตศาสตร์ ที่นำ `match_score` ข้อความ OCR และระยะเวลาในการพูดมาประเมิน (Heuristic Matrix)

- **`agenda -(agenda_has_image)-> image`**
  - เกิดจากการที่สไลด์หน้าจอมีชื่อของวาระนั้นปรากฏอยู่
  - มี Attribute: `weight` ค่าน้ำหนักอิทธิพลระหว่างรูปกับวาระ (พิจารณาจาก Time Decay หากภาพอยู่ช่วงเวลาทับซ้อนกับการอภิปรายวาระนี้)
- **`section -(section_has_image)-> image`**
  - เกิดขึ้นเมื่อโครงสร้างการรายงานสอดคล้องกับภาพ เพื่อชี้ว่าจะฝังรูปลงในย่อหน้าไหนของรายงาน HTML

**Edge เชื่อมโยงระดับลึกด้วยการคำนวณ Semantic Overlap**
เพื่อไม่ให้สไลด์ที่มีคำว่า "ฝ่ายขาย" ปรากฏไปสอดแทรกในทุกประเด็น ระบบจึงสร้าง Edge เหล่านี้:

- **`image -(image_supports_topic)-> topic`**
- **`image -(image_supports_action)-> action`**
- **`image -(image_supports_decision)-> decision`**
  _เกณฑ์การสร้าง (Creation Logic)_: ระบบจะแปลง OCR Text เป็นชุดคำศัพท์ (Token Bags) และดึงข้อความจาก Topic, Action, Decision ออกมาเทียบกันเพื่อหาคะแนน **Token Overlap Score** หากคะแนนความทับซ้อนทางความหมายมากกว่าเกณฑ์ที่ชี้ชัดได้ (เช่น `max(0.2, min_overlap)`) กราฟจะทำการสร้างเส้น Edge ให้ พร้อมระบุ Attribute: `semantic_overlap` และ `decay_weight`

---

## 4. ประโยชน์ทางเทคนิคและการดึงข้อมูลไปใช้งาน (Query Flow)

### 4.1 ฟังก์ชันกระดูกสันหลัง `query_agenda`

เมื่อ Agent จะทำการเรนเดอร์รายงานในตอนจบ มันไม่จำเป็นต้องรู้เรื่องบริบททั้งหมดของประชุม ระบบถูกออกแบบให้ Agent มีสมาธิสูงสุดด้วยฟังก์ชัน `query_agenda("ชื่อวาระ")`

- โค้ดจะนำชื่อวาระไปแปลงเป็น `agenda_id`
- ทำการท่องกราฟ (Graph Traversal) ควานหาโหนดเพื่อนบ้านทั้งหมดแบบชั้นเดียว (1-hop) และสองชั้น (2-hop)
- โค้ดจะดึงข้อมูลทั้งชุดส่งคืนในโครงสร้าง Dictionary แบบคัดกรอง 100% ว่า Topic ไหน, Action ใด, มติใด, ถ้อยคำของใครหน้าไหน และหลักฐานท่อนใด เกี่ยวข้องกับ "วาระที่เรียกขอ" ชิ้นนี้บ้าง
- LLM จะได้รับ Context Window ที่สะอาด บริสุทธิ์ ปราศจาก Noise ข้ามวาระ นำไปสู่รายงานที่สมบูรณ์แบบ

### 4.2 ระบบ Snapshot แบบ State Machine (`kg_state.json`)

Knowledge Graph ถูกออกแบบมาบนสถาปัตยกรรมแบบ Serializable

- ทุกๆ โหนดและเส้นที่ถูกเพิ่ม จะอัปเดตเข้า State Dictionary ส่วนกลาง
- ระบบจะทำการ Snapshot สถานะนี้บันทึกลงไฟล์ `kg_state.json` บนดิสก์
- **คุณสมบัติเด่น (Reusability)**: หากนักพัฒนาต้องการปรับแก้ Prompt ของการเขียนรายงาน (Generation) หรือปรับปรุงหน้าตา HTML ผู้ใช้งานไม่จำเป็นต้องเสียเงินและค่า API ในการถอดความเสียงใหม่ หรือดึง Graph ใหม่ สามารถโหลด `kg_state.json` ผ่าน Parameter `--resume-kg-json` ของรันไทม์ ทำให้สามารถเริ่มที่ขั้นตอนสุดท้าย (Generation Agent) ได้ทันที ประหยัดระยะเวลาไปกว่า 90% ของกระบวนการทั้งหมด
